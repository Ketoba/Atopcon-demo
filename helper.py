
### This code has all the helper codes for the main.py

import requests
import geopandas as gpd
from shapely.geometry import Point, box
import matplotlib.pyplot as plt
from cartopy.mpl.gridliner import LONGITUDE_FORMATTER, LATITUDE_FORMATTER
import cartopy.crs as ccrs
import cartopy.feature as cfeature
import base64
from dash import html
import io
from dash import dash_table
from matplotlib.backends.backend_pdf import PdfPages


def load_geojson(url):
    #Function to dowloand and load Geojson files into dataframe
    response = requests.get(url)
    if response.status_code == 200:
        gdf = gpd.read_file(response.text)
        return gdf
    else:
        print("Failed to download the GeoJSON file.")

def get_data_radius(latitude, longitude, bld_footprint, road_data, poi_data):
    # Load necessary data (assuming building_footprints, roads, and POIs are global variable)

    # Create circle geometry
    circle_center = Point(longitude, latitude)
    circle = circle_center.buffer(0.025)

    # Select features within the circle
    buildings_within_radius = bld_footprint[bld_footprint.geometry.intersects(circle)]
    roads_within_radius = road_data[road_data.geometry.intersects(circle)]
    pois_within_radius = poi_data[poi_data.geometry.intersects(circle)]
    return [buildings_within_radius, roads_within_radius, pois_within_radius]

def plot_map(building_data):
    # Plot map
        fig, ax = plt.subplots(figsize=(10, 10), subplot_kw={'projection': ccrs.PlateCarree()})
        building_data.plot(ax=ax, color='red')
        ax.add_feature(cfeature.COASTLINE)
        ax.add_feature(cfeature.BORDERS)
        bbox = building_data.total_bounds
        ax.set_extent([bbox[0], bbox[2], bbox[1], bbox[3]])
        gl = ax.gridlines(draw_labels=True)
        gl.xlabels_top = gl.ylabels_right = False
        gl.xformatter = LONGITUDE_FORMATTER
        gl.yformatter = LATITUDE_FORMATTER
        ax.annotate('N', xy=(0.1, 0.95), xycoords='axes fraction', ha='center', va='center',
                    arrowprops=dict(facecolor='black', arrowstyle='->', linewidth=1.5), fontsize=30)
        bbox_polygon = box(bbox[0], bbox[1], bbox[2], bbox[3])
        bbox_patch = ax.add_geometries([bbox_polygon], ccrs.PlateCarree(),
                                        facecolor='none', edgecolor='black', linewidth=1)

        # Convert the Matplotlib plot to a base64-encoded image string
        img_data = io.BytesIO()
        fig.savefig(img_data, format='png')
        img_data.seek(0)
        img_base64 = base64.b64encode(img_data.getvalue()).decode()
        return [html.Img(src=f"data:image/png;base64,{img_base64}", style={'width': 'auto', 'margin': '1px', "height": "500px"}), fig]

def build_table(pois_within_radius):
    # Convert POIs to DataFrame
    pois_df = pois_within_radius[['Name', 'Type']].copy()
    pois_df.reset_index(drop=True, inplace=True)
    return dash_table.DataTable(
            id='poi-table',
            columns=[{"name": i, "id": i} for i in pois_df.columns],
            data=pois_df.to_dict('records'),
            style_table={'overflowX': 'auto', 'color': '#000', 'width': 'auto', 'margin': '1px', "height": '500px'},
            style_cell={'backgroundColor': '#fff', 'color': '#000'}
        )

def get_bar_charts(chart):
    fig, ax = plt.subplots(figsize=(10, 6))
    chart.value_counts().plot(kind='bar', ax = ax)
    for p in ax.patches:
        ax.annotate(str(p.get_height()), (p.get_x() + p.get_width() / 2., p.get_height()),
                        ha='center', va='center', xytext=(0, 10), textcoords='offset points')
        ax.set_title('{}'.format(chart.name))
        ax.set_xlabel('Building Use' if chart.name.startswith('Chart showing Use') else 'Road Condition' if chart.name.startswith('Chart showing condition') else 'Road Class' if chart.name.startswith('Chart showing road') else 'Number of floors')
        ax.set_ylabel('Count')
        ax.tick_params(axis="x",rotation=45)
        fig.text(0.75, 0.05, 'This report was generated by Nervs', ha='left', fontsize=6.5)
        plt.tight_layout()

        # Convert matplotlib figure to base64 image
        img_data = io.BytesIO()
        fig.savefig(img_data, format='png')
        img_data.seek(0)
        img_base64 = base64.b64encode(img_data.getvalue()).decode('utf-8')
        return [html.Img(src='data:image/png;base64,{}'.format(img_base64), style={'height': '400px', 'width': 'auto'}), fig]
    
def save_plots_to_pdf_bytes(plots):
    buffer = io.BytesIO()
    with PdfPages(buffer) as pdf:
        for plot in plots[:5]:
            pdf.savefig(plot)
        # Convert DataFrame to HTML table
        dataframe = plots[-1]
        dataframe.reset_index(inplace=True)
        dataframe['s/n'] = dataframe.index
        desired_columns = ['s/n', 'Name', 'Type']

    # Rearrange columns
        dataframe = dataframe[desired_columns]
        dataframe_html = dataframe.to_html(index=True)

        # Calculate number of pages needed for the table
        num_rows = len(dataframe)
        rows_per_page = 30
        num_pages = num_rows // rows_per_page + (num_rows % rows_per_page > 0)
        
        # Create subplots for each page
        for page in range(num_pages):
            start_row = page * rows_per_page
            end_row = min((page + 1) * rows_per_page, num_rows)
            table_df = dataframe.iloc[start_row:end_row]
            
            fig, ax = plt.subplots(figsize=(10, 6))
            ax.axis('off')  # Turn off axis to display only the DataFrame
            ax.table(cellText=table_df.values, colLabels=table_df.columns,cellLoc='left', loc='center')
            plt.tight_layout()
            pdf.savefig(fig)
            plt.close(fig)
    
    buffer.seek(0)
    return buffer.getvalue()
"""
# Save the table
        fig_table = plt.figure(figsize=(8, 6))
        ax_table = fig_table.add_subplot(111)
        ax_table.axis('tight')
        ax_table.axis('off')
        table_data = poi_data.head().values.tolist()
        col_labels = poi_data.columns.tolist()
        table = ax_table.table(cellText=table_data, colLabels=col_labels, cellLoc='center', loc='center')
        pdf.savefig(fig_table)
        plt.close(fig_table)
        """
def save_report_to_pdf(fig, charts):
    with PdfPages('Nervs_Report.pdf') as pdf:
        pdf.savefig(fig)
        for i, chart in enumerate(charts):
            plt.figure(figsize=(40, 6))
            ax = chart.value_counts().plot(kind='bar')
            for p in ax.patches:
                ax.annotate(str(p.get_height()), (p.get_x() + p.get_width() / 2., p.get_height()),
                            ha='center', va='center', xytext=(0, 10), textcoords='offset points')
            plt.title('{}'.format(chart.name))
            plt.xlabel('Building Use' if chart.name.startswith('Chart showing Use') else 'Road Condition' if chart.name.startswith('Chart showing condition') else 'Road Class' if chart.name.startswith('Chart showing road') else 'Number of floors')
            plt.ylabel('Count')
            plt.xticks(rotation=45)
            plt.annotate('This report was generated by Nervs', (0.75, 0.05), xycoords='figure fraction', ha='left', fontsize=6.5)
            plt.tight_layout()
            pdf.savefig()
            plt.close()
    return pdf